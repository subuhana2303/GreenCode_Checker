from datetime import datetime
from typing import Dict, List, Any

class ReportGenerator:
    """Generates downloadable reports for code analysis results"""
    
    def generate_report(self, username: str, code: str, analysis_results: Dict[str, Any], 
                       suggestions: List[str], green_score: int) -> str:
        """Generate a comprehensive text report"""
        
        report_lines = []
        
        # Header
        report_lines.extend([
            "=" * 60,
            "🌿 GREEN CODE CHECKER - ANALYSIS REPORT",
            "=" * 60,
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Analyst: {username}",
            "",
        ])
        
        # Green Score Section
        report_lines.extend([
            "📊 GREEN SCORE SUMMARY",
            "-" * 30,
            f"Overall Green Score: {green_score}/100",
            self._get_score_interpretation(green_score),
            "",
        ])
        
        # Code Statistics
        report_lines.extend([
            "📈 CODE STATISTICS",
            "-" * 30,
            f"Lines of Code: {analysis_results.get('lines_of_code', 0)}",
            f"Functions: {analysis_results.get('function_count', 0)}",
            f"Imports: {analysis_results.get('import_count', 0)}",
            f"For Loops: {analysis_results.get('for_loop_count', 0)}",
            f"While Loops: {analysis_results.get('while_loop_count', 0)}",
            f"Complexity Score: {analysis_results.get('complexity_score', 0)}",
            "",
        ])
        
        # Issues Found
        issues = analysis_results.get('issues', [])
        if issues:
            report_lines.extend([
                "⚠️  ISSUES IDENTIFIED",
                "-" * 30,
            ])
            for i, issue in enumerate(issues, 1):
                report_lines.extend([
                    f"{i}. {issue['type'].replace('_', ' ').title()}",
                    f"   Line {issue['line']}: {issue['description']}",
                    f"   💡 Suggestion: {issue.get('suggestion', 'No specific suggestion available')}",
                    "",
                ])
        else:
            report_lines.extend([
                "✅ ISSUES IDENTIFIED",
                "-" * 30,
                "No major issues found! Your code follows good practices.",
                "",
            ])
        
        # Optimization Suggestions
        if suggestions:
            report_lines.extend([
                "💡 OPTIMIZATION SUGGESTIONS",
                "-" * 30,
            ])
            for i, suggestion in enumerate(suggestions, 1):
                # Clean suggestion text (remove emojis for plain text report)
                clean_suggestion = self._clean_suggestion_text(suggestion)
                report_lines.append(f"{i}. {clean_suggestion}")
            report_lines.append("")
        
        # Best Practices Section
        report_lines.extend([
            "🌱 GREEN CODING BEST PRACTICES",
            "-" * 30,
            "1. Use list comprehensions instead of loops when appropriate",
            "2. Avoid unnecessary imports and clean up unused code",
            "3. Choose appropriate data structures for your use case",
            "4. Use generators for memory-efficient iteration",
            "5. Profile before optimizing - measure twice, cut once",
            "6. Write readable code first, optimize later based on actual needs",
            "7. Use built-in functions and libraries - they're optimized",
            "8. Consider the environmental impact of your code choices",
            "",
        ])
        
        # Code Analysis Details
        if len(code.strip()) > 0:
            report_lines.extend([
                "📝 ANALYZED CODE",
                "-" * 30,
                code,
                "",
            ])
        
        # Footer
        report_lines.extend([
            "=" * 60,
            "Report generated by Green Code Checker",
            "🌿 Building a more sustainable future, one line of code at a time",
            "=" * 60,
        ])
        
        return "\n".join(report_lines)
    
    def _get_score_interpretation(self, score: int) -> str:
        """Get interpretation of the green score"""
        if score >= 90:
            return "🌟 Excellent! Your code is highly sustainable and efficient."
        elif score >= 75:
            return "✅ Good job! Your code follows most sustainability practices."
        elif score >= 50:
            return "⚠️ Room for improvement. Consider the suggestions below."
        elif score >= 25:
            return "🔧 Significant improvements needed for better sustainability."
        else:
            return "❌ Major refactoring recommended for sustainable code practices."
    
    def _clean_suggestion_text(self, suggestion: str) -> str:
        """Remove emojis and clean suggestion text for plain text report"""
        # Simple emoji removal (remove common emojis used in suggestions)
        emoji_patterns = ['🌱', '⚡', '🔄', '🧹', '🎯', '💾', '🔧', '📚', '📦']
        clean_text = suggestion
        for emoji in emoji_patterns:
            clean_text = clean_text.replace(emoji, '').strip()
        return clean_text
    
    def generate_summary_stats(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate summary statistics for the analysis"""
        return {
            'total_issues': len(analysis_results.get('issues', [])),
            'critical_issues': len([issue for issue in analysis_results.get('issues', []) 
                                  if issue['type'] in ['while_loop', 'unused_import']]),
            'code_quality_ratio': self._calculate_quality_ratio(analysis_results),
            'efficiency_score': self._calculate_efficiency_score(analysis_results)
        }
    
    def _calculate_quality_ratio(self, results: Dict[str, Any]) -> float:
        """Calculate code quality ratio"""
        total_lines = results.get('lines_of_code', 1)
        total_issues = len(results.get('issues', []))
        return max(0, (total_lines - total_issues) / total_lines)
    
    def _calculate_efficiency_score(self, results: Dict[str, Any]) -> int:
        """Calculate efficiency score based on patterns"""
        base_score = 100
        deductions = 0
        
        deductions += results.get('while_loop_count', 0) * 10
        deductions += results.get('inefficient_patterns_count', 0) * 15
        deductions += results.get('unused_imports_count', 0) * 5
        
        return max(0, base_score - deductions)
